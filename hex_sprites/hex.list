ca65 V2.19 - Git 8e6c0c1
Main file   : hex.s
Current file: hex.s

000000r 1               ; 	080D
000000r 1  4C rr rr     jmp start ; 	3 bytes
000003r 1               ;	0810 	- 240 bytes available for stuff that doesn't need alignment
000003r 1  DE AD BE EF  .repeat 28
000007r 1  DE AD BE EF  
00000Br 1  DE AD BE EF  
000073r 1               	.byte $DE,$AD,$BE,$EF
000073r 1               .endrepeat
000073r 1               SCRATCH128:
000073r 1  DE AD BE EF  .repeat 32
000077r 1  DE AD BE EF  
00007Br 1  DE AD BE EF  
0000F3r 1               	.byte $DE,$AD,$BE,$EF
0000F3r 1               .endrepeat
0000F3r 1               
0000F3r 1               ACROSS_ROW_X_H: ; 0900
0000F3r 1               ;     0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
0000F3r 1  10 0F 0F 0F  .byte $10,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $E
0000F7r 1  0F 0F 0F 0F  
0000FBr 1  0F 0F 0F 0F  
000103r 1  0E 0E 0E 0E  .byte  $E,  $E,  $E,  $E,  $E,  $D,  $D,  $D,  $D,  $D,  $C,  $C,  $C,  $C,  $B,  $B
000107r 1  0E 0D 0D 0D  
00010Br 1  0D 0D 0C 0C  
000113r 1  0B 0B 0A 0A  .byte  $B,  $B,  $A,  $A,  $A,  $9,  $9,  $9,  $8,  $8,  $8,  $7,  $7,  $7,  $6,  $6
000117r 1  0A 09 09 09  
00011Br 1  08 08 08 07  
000123r 1  06 05 05 05  .byte  $6,  $5,  $5,  $5,  $4,  $4,  $3,  $3,  $3,  $2,  $2,  $1,  $1,  $1,  $0,  $0
000127r 1  04 04 03 03  
00012Br 1  03 02 02 01  
000133r 1  00 FF FF FE  .byte  $0, $FF, $FF, $FE, $FE, $FE, $FD, $FD, $FC, $FC, $FC, $FB, $FB, $FA, $FA, $FA
000137r 1  FE FE FD FD  
00013Br 1  FC FC FC FB  
000143r 1  F9 F9 F9 F8  .byte $F9, $F9, $F9, $F8, $F8, $F8, $F7, $F7, $F7, $F6, $F6, $F6, $F5, $F5, $F5, $F4
000147r 1  F8 F8 F7 F7  
00014Br 1  F7 F6 F6 F6  
000153r 1  F4 F4 F4 F3  .byte $F4, $F4, $F4, $F3, $F3, $F3, $F3, $F2, $F2, $F2, $F2, $F2, $F1, $F1, $F1, $F1
000157r 1  F3 F3 F3 F2  
00015Br 1  F2 F2 F2 F2  
000163r 1  F1 F1 F0 F0  .byte $F1, $F1, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0
000167r 1  F0 F0 F0 F0  
00016Br 1  F0 F0 F0 F0  
000173r 1  F0 F0 F0 F0  .byte $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F1
000177r 1  F0 F0 F0 F0  
00017Br 1  F0 F0 F0 F0  
000183r 1  F1 F1 F1 F1  .byte $F1, $F1, $F1, $F1, $F1, $F2, $F2, $F2, $F2, $F2, $F3, $F3, $F3, $F3, $F4, $F4
000187r 1  F1 F2 F2 F2  
00018Br 1  F2 F2 F3 F3  
000193r 1  F4 F4 F5 F5  .byte $F4, $F4, $F5, $F5, $F5, $F6, $F6, $F6, $F7, $F7, $F7, $F8, $F8, $F8, $F9, $F9
000197r 1  F5 F6 F6 F6  
00019Br 1  F7 F7 F7 F8  
0001A3r 1  F9 FA FA FA  .byte $F9, $FA, $FA, $FA, $FB, $FB, $FC, $FC, $FC, $FD, $FD, $FE, $FE, $FE, $FF, $FF
0001A7r 1  FB FB FC FC  
0001ABr 1  FC FD FD FE  
0001B3r 1  00 00 00 01  .byte $00,  $0,  $0,  $1,  $1,  $1,  $2,  $2,  $3,  $3,  $3,  $4,  $4,  $5,  $5,  $5
0001B7r 1  01 01 02 02  
0001BBr 1  03 03 03 04  
0001C3r 1  06 06 06 07  .byte  $6,  $6,  $6,  $7,  $7,  $7,  $8,  $8,  $8,  $9,  $9,  $9,  $A,  $A,  $A,  $B
0001C7r 1  07 07 08 08  
0001CBr 1  08 09 09 09  
0001D3r 1  0B 0B 0B 0C  .byte  $B,  $B,  $B,  $C,  $C,  $C,  $C,  $D,  $D,  $D,  $D,  $D,  $E,  $E,  $E,  $E
0001D7r 1  0C 0C 0C 0D  
0001DBr 1  0D 0D 0D 0D  
0001E3r 1  0E 0E 0F 0F  .byte  $E,  $E,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F,  $F
0001E7r 1  0F 0F 0F 0F  
0001EBr 1  0F 0F 0F 0F  
0001F3r 1               
0001F3r 1               ACROSS_ROW_X_L: ; 0A00
0001F3r 1               ;     0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
0001F3r 1  00 FE FB F4  .byte  $0, $FE, $FB, $F4, $EC, $E1, $D3, $C3, $B1, $9C, $85, $6B, $4F, $31, $10, $ED
0001F7r 1  EC E1 D3 C3  
0001FBr 1  B1 9C 85 6B  
000203r 1  C8 A0 76 4A  .byte $C8, $A0, $76, $4A, $1C, $EB, $B9, $84, $4D, $14, $D9, $9D, $5E, $1D, $DA, $96
000207r 1  1C EB B9 84  
00020Br 1  4D 14 D9 9D  
000213r 1  50 08 BE 73  .byte $50,  $8, $BE, $73, $26, $D7, $87, $36, $E3, $8F, $39, $E2, $8A, $31, $D7, $7B
000217r 1  26 D7 87 36  
00021Br 1  E3 8F 39 E2  
000223r 1  1F C2 63 04  .byte $1F, $C2, $63,  $4, $A5, $44, $E3, $81, $1F, $BC, $59, $F5, $91, $2D, $C8, $64
000227r 1  A5 44 E3 81  
00022Br 1  1F BC 59 F5  
000233r 1  00 9B 37 D2  .byte  $0, $9B, $37, $D2, $6E,  $A, $A6, $43, $E0, $7E, $1C, $BB, $5A, $FB, $9C, $3D
000237r 1  6E 0A A6 43  
00023Br 1  E0 7E 1C BB  
000243r 1  E0 84 28 CE  .byte $E0, $84, $28, $CE, $75, $1D, $C6, $70, $1C, $C9, $78, $28, $D9, $8C, $41, $F7
000247r 1  75 1D C6 70  
00024Br 1  1C C9 78 28  
000253r 1  AF 69 25 E2  .byte $AF, $69, $25, $E2, $A1, $62, $26, $EB, $B2, $7B, $46, $14, $E3, $B5, $89, $5F
000257r 1  A1 62 26 EB  
00025Br 1  B2 7B 46 14  
000263r 1  37 12 EF CE  .byte $37, $12, $EF, $CE, $B0, $94, $7A, $63, $4E, $3C, $2C, $1E, $13,  $B,  $4,  $1
000267r 1  B0 94 7A 63  
00026Br 1  4E 3C 2C 1E  
000273r 1  00 01 04 0B  .byte  $0,  $1,  $4,  $B, $13, $1E, $2C, $3C, $4E, $63, $7A, $94, $B0, $CE, $EF, $12
000277r 1  13 1E 2C 3C  
00027Br 1  4E 63 7A 94  
000283r 1  37 5F 89 B5  .byte $37, $5F, $89, $B5, $E3, $14, $46, $7B, $B2, $EB, $26, $62, $A1, $E2, $25, $69
000287r 1  E3 14 46 7B  
00028Br 1  B2 EB 26 62  
000293r 1  AF F7 41 8C  .byte $AF, $F7, $41, $8C, $D9, $28, $78, $C9, $1C, $70, $C6, $1D, $75, $CE, $28, $84
000297r 1  D9 28 78 C9  
00029Br 1  1C 70 C6 1D  
0002A3r 1  E0 3D 9C FB  .byte $E0, $3D, $9C, $FB, $5A, $BB, $1C, $7E, $E0, $43, $A6,  $A, $6E, $D2, $37, $9B
0002A7r 1  5A BB 1C 7E  
0002ABr 1  E0 43 A6 0A  
0002B3r 1  00 64 C8 2D  .byte  $0, $64, $C8, $2D, $91, $F5, $59, $BC, $1F, $81, $E3, $44, $A5,  $4, $63, $C2
0002B7r 1  91 F5 59 BC  
0002BBr 1  1F 81 E3 44  
0002C3r 1  1F 7B D7 31  .byte $1F, $7B, $D7, $31, $8A, $E2, $39, $8F, $E3, $36, $87, $D7, $26, $73, $BE,  $8
0002C7r 1  8A E2 39 8F  
0002CBr 1  E3 36 87 D7  
0002D3r 1  50 96 DA 1D  .byte $50, $96, $DA, $1D, $5E, $9D, $D9, $14, $4D, $84, $B9, $EB, $1C, $4A, $76, $A0
0002D7r 1  5E 9D D9 14  
0002DBr 1  4D 84 B9 EB  
0002E3r 1  C8 ED 10 31  .byte $C8, $ED, $10, $31, $4F, $6B, $85, $9C, $B1, $C3, $D3, $E1, $EC, $F4, $FB, $FE
0002E7r 1  4F 6B 85 9C  
0002EBr 1  B1 C3 D3 E1  
0002F3r 1               
0002F3r 1               ACROSS_ROW_Y_H: ; 0B00
0002F3r 1               ;     0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
0002F3r 1  00 00 00 00  .byte  $0,  $0,  $0,  $0,  $0,  $0,  $1, $1, $1, $1, $1, $2, $2, $2, $2, $2, $3, $3, $3, $3, $3, $3, $4, $4, $4, $4, $4, $4, $5, $5, $5, $5, $5, $5, $5, $6, $6, $6, $6, $6, $6, $6, $6, $6, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $8, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $7, $6, $6, $6, $6, $6, $6, $6, $6, $6, $5, $5, $5, $5, $5, $5, $5, $4, $4, $4, $4, $4, $4, $3, $3, $3, $3, $3, $3, $2, $2, $2, $2, $2, $1, $1, $1, $1, $1, $0, $0, $0, $0, $0, $0, $FF, $FF, $FF, $FF, $FF, $FE, $FE, $FE, $FE, $FE, $FD, $FD, $FD, $FD, $FD, $FC, $FC, $FC, $FC, $FC, $FC, $FB, $FB, $FB, $FB, $FB, $FB, $FA, $FA, $FA, $FA, $FA, $FA, $FA, $F9, $F9, $F9, $F9, $F9, $F9, $F9, $F9, $F9, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F9, $F9, $F9, $F9, $F9, $F9, $F9, $F9, $F9, $FA, $FA, $FA, $FA, $FA, $FA, $FA, $FB, $FB, $FB, $FB, $FB, $FB, $FC, $FC, $FC, $FC, $FC, $FC, $FD, $FD, $FD, $FD, $FD, $FE, $FE, $FE, $FE, $FE, $FF, $FF, $FF, $FF, $FF
0002F7r 1  00 00 01 01  
0002FBr 1  01 01 01 02  
0003F3r 1               
0003F3r 1               ACROSS_ROW_Y_L: ; 0C00
0003F3r 1               ;     0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
0003F3r 1  00 32 64 96  .byte  $0, $32, $64, $96, $C8, $FA, $2C, $5E, $8F, $C0, $F1, $22, $52, $82
0003F7r 1  C8 FA 2C 5E  
0003FBr 1  8F C0 F1 22  
000401r 1  B1 E1 0F 3D  .byte $B1, $E1,  $F, $3D, $6B, $98, $C5, $F1, $1C, $47, $71, $9B, $C3
000405r 1  6B 98 C5 F1  
000409r 1  1C 47 71 9B  
00040Er 1  EB 13 39 5F  .byte $EB, $13, $39, $5F, $84, $A8, $CB, $ED,  $E, $2F, $4E, $6C, $8A
000412r 1  84 A8 CB ED  
000416r 1  0E 2F 4E 6C  
00041Br 1  A6 C2 DC F5  .byte $A6, $C2, $DC, $F5,  $E, $25, $3B, $50, $64, $76, $88, $98, $A7
00041Fr 1  0E 25 3B 50  
000423r 1  64 76 88 98  
000428r 1  B5 C2 CE D8  .byte $B5, $C2, $CE, $D8, $E1, $E9, $F0, $F6, $FA, $FD, $FF,  $0, $FF
00042Cr 1  E1 E9 F0 F6  
000430r 1  FA FD FF 00  
000435r 1  FD FA F6 F0  .byte $FD, $FA, $F6, $F0, $E9, $E1, $D8, $CE, $C2, $B5, $A7, $98, $88
000439r 1  E9 E1 D8 CE  
00043Dr 1  C2 B5 A7 98  
000442r 1  76 64 50 3B  .byte $76, $64, $50, $3B, $25,  $E, $F5, $DC, $C2, $A6, $8A, $6C, $4E
000446r 1  25 0E F5 DC  
00044Ar 1  C2 A6 8A 6C  
00044Fr 1  2F 0E ED CB  .byte $2F, $E, $ED, $CB, $A8, $84, $5F, $39, $13, $EB, $C3, $9B, $71, $47, $1C, $F1, $C5, $98, $6B, $3D, $F, $E1, $B1, $82, $52, $22, $F1, $C0, $8F, $5E, $2C, $FA, $C8, $96, $64, $32, $0, $CD, $9B, $69, $37, $5, $D3, $A1, $70, $3F, $E, $DD, $AD, $7D, $4E, $1E, $F0, $C2, $94, $67, $3A, $E, $E3, $B8, $8E, $64, $3C, $14, $EC, $C6, $A0, $7B, $57, $34, $12, $F1, $D0, $B1, $93, $75, $59, $3D, $23, $A, $F1, $DA, $C4, $AF, $9B, $89, $77, $67, $58, $4A, $3D, $31, $27, $1E, $16, $F, $9, $5, $2, $0, $0, $0, $2, $5, $9, $F, $16, $1E, $27, $31, $3D, $4A, $58, $67, $77, $89, $9B, $AF, $C4, $DA, $F1, $A, $23, $3D, $59, $75, $93, $B1, $D0, $F1, $12, $34, $57, $7B, $A0, $C6, $EC, $14, $3C, $64, $8E, $B8, $E3, $E, $3A, $67, $94, $C2, $F0, $1E, $4E, $7D, $AD, $DD, $E, $3F, $70, $A1, $D3, $5, $37, $69, $9B, $CD
000453r 1  A8 84 5F 39  
000457r 1  13 EB C3 9B  
0004F3r 1               
0004F3r 1               
0004F3r 1               ;constants
0004F3r 1               
0004F3r 1               ; RAM Interrupt Vectors
0004F3r 1               IRQVec            = $0314
0004F3r 1               
0004F3r 1               ; VERA
0004F3r 1               VERA_addr_low     = $9F20
0004F3r 1               VERA_addr_high    = $9F21
0004F3r 1               VERA_addr_bank    = $9F22
0004F3r 1               VERA_data0        = $9F23
0004F3r 1               VERA_data1        = $9F24
0004F3r 1               VERA_ctrl         = $9F25
0004F3r 1               VERA_ien          = $9F26
0004F3r 1               VERA_isr          = $9F27
0004F3r 1               VERA_dc_video     = $9F29 ; DCSEL = 0
0004F3r 1               ;   Current Field | Sprites Enable | Layer1 Enable  |Layer0 Enable
0004F3r 1               ; NTSC/RGB: 240P  | NTSC: Chroma Disable / RGB: HV Sync Output Mode
0004F3r 1               
0004F3r 1               VERA_dc_hscale    = $9F2A
0004F3r 1               VERA_dc_vscale    = $9F2B
0004F3r 1               
0004F3r 1               VERA_L0_config    = $9F2D
0004F3r 1               ;   7       6     5   4       3       2             1   0
0004F3r 1               ;   Map Height | Map Width | T256C | Bitmap Mode | Color Depth
0004F3r 1               ;   0 - 32                  0 - 16    0 tiled       0   1bpp mono
0004F3r 1               ;   1 - 64                  1 - 256   1 enabled     1   2bpp 4 color
0004F3r 1               ;   2 - 128                                         2   4bpp 16 color
0004F3r 1               ;   3 - 256                                         3   8bpp 256 color
0004F3r 1               ;   bitmap mode - tilebase points to bitmap data, mapbase not used
0004F3r 1               ;   tile width = 0 is 320 pixels / tile width=1 is 640 pixels.. so could do 4bpp x 320?
0004F3r 1               ;   The palette offset (in 'H-Scroll (11:8)') modifies the color indexes of the bitmap in the same way as in the tile modes.
0004F3r 1               
0004F3r 1               VERA_L0_mapbase   = $9F2E
0004F3r 1               VERA_L0_tilebase  = $9F2F ;   Tile Base Address (16:11) | Tile Height 0-8/1-16 | Tile Width 0-8/1-16
0004F3r 1               VERA_L0_HSCROLL_L = $9F30 ;  H-Scroll (7:0)
0004F3r 1               VERA_L0_HSCROLL_H = $9F31 ;  - H-Scroll (11:8)
0004F3r 1               VERA_L0_VSCROLL_L = $9F32 ;  V-Scroll (7:0)
0004F3r 1               VERA_L0_VSCROLL_H = $9F33 ;  - V-Scroll (11:8)
0004F3r 1               
0004F3r 1               VERA_L1_config    = $9F34
0004F3r 1               VERA_L1_mapbase   = $9F35
0004F3r 1               VERA_L1_tilebase  = $9F36
0004F3r 1               VERA_L1_HSCROLL_L = $9F37 ;  H-Scroll (7:0)
0004F3r 1               VERA_L1_HSCROLL_H = $9F38 ;  - H-Scroll (11:8)
0004F3r 1               VERA_L1_VSCROLL_L = $9F39 ;  V-Scroll (7:0)
0004F3r 1               VERA_L1_VSCROLL_H = $9F3A ;  - V-Scroll (11:8)
0004F3r 1               
0004F3r 1               VSYNC_BIT         = $01
0004F3r 1               
0004F3r 1               ; VRAM Addresses
0004F3r 1               ;   Address range Description
0004F3r 1               ;   $00000 - $1F9BF Video RAM   - 129,424 bytes -> 126K is 129,024 (1F800)
0004F3r 1               ;   $1F9C0 - $1F9FF PSG registers
0004F3r 1               ;   $1FA00 - $1FBFF Palette
0004F3r 1               ;   $1FC00 - $1FFFF Sprite attributes
0004F3r 1               
0004F3r 1               VRAM_UNRESERVED   = $1A000      ;
0004F3r 1               ; sprite starts must be 32byte aligned...
0004F3r 1               ; only can go to 126K ...
0004F3r 1               VRAM_palette      = $1FA00      ;
0004F3r 1               VRAM_sprite_attributes = $1FC00
0004F3r 1               
0004F3r 1               SPRITES_ONLY_VGA = $41
0004F3r 1               
0004F3r 1               
0004F3r 1               
0004F3r 1               ; Kernal
0004F3r 1               CHROUT            = $FFD2
0004F3r 1               GETIN             = $FFE4
0004F3r 1               CINT              = $FF81
0004F3r 1               
0004F3r 1               
0004F3r 1               ; PETSCII Codes
0004F3r 1               WHITE             = $05
0004F3r 1               RETURN            = $0D
0004F3r 1               SPACE             = $20
0004F3r 1               ZERO_CHAR         = $30
0004F3r 1               SIX_CHAR          = $36
0004F3r 1               NINE_CHAR         = $39
0004F3r 1               C_CHAR            = $43
0004F3r 1               I_CHAR            = $49
0004F3r 1               O_CHAR            = $4F
0004F3r 1               T_CHAR            = $54
0004F3r 1               CLR               = $93
0004F3r 1               
0004F3r 1               ; 	$0800-$9EFF	BASIC program/variables; available to the user
0004F3r 1               WORLD_DATA = $6000 	;	so is %100 [Y 5 bits ] : [ab] 0 [X - 6 bits
0004F3r 1               SCREEN_buffer = $8000
0004F3r 1               
0004F3r 1               ; zero page layout $0022-$007F is available to user
0004F3r 1               ZP_PTR = $22
0004F3r 1               SCRATCH_PTR = $7E
0004F3r 1               ; global data
0004F3r 1  DE AD BE EF  .byte $DE,$AD,$BE,$EF
0004F7r 1  00 00        default_irq_vector:  .addr 0
0004F9r 1  01           VSYNC_counter:       .byte 1
0004FAr 1  01           camera_facing: 		 .byte 1
0004FBr 1               
0004FBr 1               
0004FBr 1               .macro stash_scratch
0004FBr 1               	STA (SCRATCH_PTR)
0004FBr 1                   INC SCRATCH_PTR
0004FBr 1               .endmacro
0004FBr 1               
0004FBr 1               custom_irq_handler:
0004FBr 1  AD 27 9F        lda VERA_isr
0004FEr 1  29 01           and #VSYNC_BIT
000500r 1  F0 03           beq @continue ; non-VSYNC IRQ, no tick update
000502r 1  EE rr rr        inc VSYNC_counter
000505r 1               @continue:
000505r 1                  ; continue to default IRQ handler
000505r 1  6C rr rr        jmp (default_irq_vector)
000508r 1                  ; RTI will happen after jump
000508r 1               
000508r 1               start:
000508r 1                 ; start of program - init globals
000508r 1  AD 14 03       lda IRQVec
00050Br 1  8D rr rr       sta default_irq_vector
00050Er 1  AD 15 03       lda IRQVec+1
000511r 1  8D rr rr       sta default_irq_vector+1
000514r 1  9C 29 9F       stz VERA_dc_video   ; disable display
000517r 1  A9 20          lda #32 ; set scale for bitmap mode - going for 160x120 mode
000519r 1  8D 2A 9F       sta VERA_dc_hscale
00051Cr 1  8D 2B 9F       sta VERA_dc_vscale
00051Fr 1                 ; for now no L0 or L1
00051Fr 1               
00051Fr 1                 ; let's stick that test sprite data into VRAM at zero for now..
00051Fr 1  9C 25 9F       stz VERA_ctrl
000522r 1  9C 20 9F       stz VERA_addr_low
000525r 1  9C 21 9F       stz VERA_addr_high
000528r 1  A9 10          lda #$10
00052Ar 1  8D 22 9F       sta VERA_addr_bank
00052Dr 1                 ; is 512 bytes at test_cell_sprite label
00052Dr 1  A2 00          ldx #0
00052Fr 1                 @copy_to_vram_loop:
00052Fr 1  BD rr rr       	  lda test_cell_sprite_16x8,X
000532r 1  8D 23 9F       	  sta VERA_data0
000535r 1  E8             	  inx
000536r 1  E0 40          	  CPX #64
000538r 1  D0 F5          	  BNE @copy_to_vram_loop
00053Ar 1               
00053Ar 1                 ; enable display
00053Ar 1  9C 25 9F       stz VERA_ctrl
00053Dr 1  A9 41          lda #SPRITES_ONLY_VGA
00053Fr 1  8D 29 9F       sta VERA_dc_video
000542r 1               
000542r 1                 ; overwrite RAM IRQ vector with custom handler address
000542r 1  78             sei ; disable IRQ while vector is changing
000543r 1  A9 rr          lda #<custom_irq_handler
000545r 1  8D 14 03       sta IRQVec
000548r 1  A9 rr          lda #>custom_irq_handler
00054Ar 1  8D 15 03       sta IRQVec+1
00054Dr 1  A9 01          lda #VSYNC_BIT ; make VERA only generate VSYNC IRQs
00054Fr 1  8D 26 9F       sta VERA_ien
000552r 1  58             cli ; enable IRQ now that vector is properly set
000553r 1               
000553r 1                 ; main loop here...
000553r 1               @FRAME_CHECK:
000553r 1  A9 04           lda #4
000555r 1                 @frame_A:
000555r 1  CB              wai
000556r 1  AC rr rr        ldy VSYNC_counter
000559r 1  F0 FA           beq @frame_A
00055Br 1  9C rr rr        stz VSYNC_counter
00055Er 1  3A              DEC A
00055Fr 1  D0 F4           BNE @frame_A
000561r 1               
000561r 1                  ; poll keyboard for input
000561r 1  20 E4 FF        jsr GETIN
000564r 1  C9 00           cmp #0
000566r 1  F0 EB           beq @FRAME_CHECK
000568r 1  C9 20           cmp #SPACE
00056Ar 1  D0 08           bne @cleanup_and_exit
00056Cr 1               
00056Cr 1                  ; switch to next bearing
00056Cr 1  EE rr rr        INC camera_facing
00056Fr 1                  ; update screen
00056Fr 1                  ; jsr draw_world
00056Fr 1  20 rr rr        jsr draw_test
000572r 1  80 DF           bra @FRAME_CHECK
000574r 1               
000574r 1               @cleanup_and_exit:
000574r 1                  ; restore default IRQ vector
000574r 1  78              sei
000575r 1  AD rr rr        lda default_irq_vector
000578r 1  8D 14 03        sta IRQVec
00057Br 1  AD rr rr        lda default_irq_vector+1
00057Er 1  8D 15 03        sta IRQVec+1
000581r 1  58              cli
000582r 1  20 81 FF        jsr CINT
000585r 1  60              rts
000586r 1               
000586r 1               ; all the objects need to get into a structure to be drawn at each screen Y..
000586r 1               ; need object type, screenX .. store back to front .. track # objects to be drawn ?
000586r 1               ; there's 120 lines on screen.. up to say 32 objects per line would need about 8K RAM for the list.. each line needs 64 bytes
000586r 1               
000586r 1               draw_test:
000586r 1  A9 rr        	LDA #>SCRATCH128 	;	setup debug pointer
000588r 1  85 7F        	STA $7F
00058Ar 1  A9 rr        	LDA #<SCRATCH128
00058Cr 1  85 7E        	STA $7E
00058Er 1  9C 20 9F         stz VERA_addr_low
000591r 1  A9 FC            lda #>VRAM_sprite_attributes
000593r 1  8D 21 9F         sta VERA_addr_high
000596r 1  A9 11            lda #$11
000598r 1  8D 22 9F         sta VERA_addr_bank
00059Br 1                   ; load increments and set start position...
00059Br 1  AE rr rr         LDX camera_facing
00059Er 1                   ; stash camera facing to scratch
00059Er 1  8A               TXA
00059Fr 1  92 7E E6 7E  	stash_scratch
0005A3r 1  92 7E E6 7E  	stash_scratch
0005A7r 1  92 7E E6 7E  	stash_scratch
0005ABr 1  92 7E E6 7E  	stash_scratch
0005AFr 1  92 7E E6 7E  	stash_scratch
0005B3r 1  92 7E E6 7E  	stash_scratch
0005B7r 1  92 7E E6 7E  	stash_scratch
0005BBr 1  92 7E E6 7E  	stash_scratch
0005BFr 1               
0005BFr 1               
0005BFr 1  BD rr rr         LDA ACROSS_ROW_X_L,X
0005C2r 1  85 26            STA ZP_PTR+4 	; 	ZP_PTR+4 = spriteX increment Low byte
0005C4r 1  64 26            STZ ZP_PTR+4 	; 	ZP_PTR+4 = spriteX increment Low byte
0005C6r 1  92 7E E6 7E  	stash_scratch
0005CAr 1               
0005CAr 1  64 23            STZ ZP_PTR+1
0005CCr 1  BD rr rr         LDA ACROSS_ROW_X_H,X
0005CFr 1  85 27            STA ZP_PTR+5
0005D1r 1  92 7E E6 7E  	stash_scratch
0005D5r 1  C9 00            CMP #0
0005D7r 1  10 04            BPL @going_right
0005D9r 1  A9 90            LDA #144
0005DBr 1  85 23            STA ZP_PTR+1
0005DDr 1                 @going_right:
0005DDr 1  BD rr rr         LDA ACROSS_ROW_Y_L,X
0005E0r 1  85 28            STA ZP_PTR+6 	; 	ZP_PTR+6 = spriteY increment low byte
0005E2r 1                  ; STZ ZP_PTR+6 	; 	ZP_PTR+6 = spriteY increment low byte
0005E2r 1  92 7E E6 7E  	stash_scratch
0005E6r 1  64 25            STZ ZP_PTR+3
0005E8r 1  BD rr rr         LDA ACROSS_ROW_Y_H,X
0005EBr 1  85 29            STA ZP_PTR+7 	; 	ZP_PTR+3 = spriteY increment
0005EDr 1  92 7E E6 7E      stash_scratch
0005F1r 1  C9 00            CMP #0
0005F3r 1  10 04            BPL @going_down
0005F5r 1  A9 70            LDA #112
0005F7r 1  85 25            STA ZP_PTR+3
0005F9r 1                 @going_down:
0005F9r 1  A0 80            LDY #128 		;	amount of sprites we can write max
0005FBr 1  84 22            STY ZP_PTR
0005FDr 1  84 24            STY ZP_PTR+2
0005FFr 1               
0005FFr 1                 @loop:
0005FFr 1  8A             	  TXA
000600r 1  92 7E E6 7E    	  stash_scratch
000604r 1  98             	  TYA
000605r 1  92 7E E6 7E    	  stash_scratch
000609r 1               
000609r 1  9C 23 9F           STZ VERA_data0 ; 	address 12:5
00060Cr 1  9C 23 9F           STZ VERA_data0 ;  mode  | address 16:13
00060Fr 1  A5 23              LDA ZP_PTR+1
000611r 1  8D 23 9F           STA VERA_data0 ; 	X 7:0
000614r 1  92 7E E6 7E        stash_scratch
000618r 1               
000618r 1  9C 23 9F           STZ VERA_data0 ; 	X 9:8
00061Br 1  A5 25              LDA ZP_PTR+3  ; 	spriteY
00061Dr 1  8D 23 9F           STA VERA_data0 ;  Y 7:0
000620r 1  92 7E E6 7E        stash_scratch
000624r 1               
000624r 1  9C 23 9F           STZ VERA_data0 ; 	Y 9:8
000627r 1  A9 0C              LDA #$0C
000629r 1  8D 23 9F           STA VERA_data0 	; 	3 z depth no flip
00062Cr 1  A9 10              LDA #$10 			; 	16x8 no palette offset
00062Er 1  8D 23 9F           STA VERA_data0
000631r 1                   ; increment X
000631r 1  A5 22              LDA ZP_PTR 	;	load X_l
000633r 1  65 26              ADC ZP_PTR+4
000635r 1  85 22              STA ZP_PTR
000637r 1  92 7E E6 7E        stash_scratch
00063Br 1               
00063Br 1  A5 23              LDA ZP_PTR+1
00063Dr 1  65 27              ADC ZP_PTR+5
00063Fr 1  92 7E E6 7E        stash_scratch
000643r 1  C9 A0              CMP #160
000645r 1  B0 27              BCS @end 		; covers negatives even..
000647r 1  85 23              STA ZP_PTR+1
000649r 1                   ; increment Y
000649r 1  A5 24              LDA ZP_PTR+2 	;
00064Br 1  65 28              ADC ZP_PTR+6
00064Dr 1  85 24              STA ZP_PTR+2
00064Fr 1  92 7E E6 7E        stash_scratch
000653r 1               
000653r 1  A5 25              LDA ZP_PTR+3
000655r 1  65 29              ADC ZP_PTR+7
000657r 1  92 7E E6 7E        stash_scratch
00065Br 1  C9 78              CMP #120
00065Dr 1  B0 0F              BCS @end 		; 	 covers negatives even..
00065Fr 1  85 25              STA ZP_PTR+3
000661r 1               
000661r 1  A9 FF              LDA #$FF
000663r 1  92 7E E6 7E        stash_scratch
000667r 1  92 7E E6 7E        stash_scratch
00066Br 1               
00066Br 1  88                 DEY
00066Cr 1  D0 91              BNE @loop
00066Er 1                 @end:
00066Er 1  60                 rts
00066Fr 1               
00066Fr 1               
00066Fr 1               draw_world:
00066Fr 1                 ; clear first entry for each line...
00066Fr 1  64 22          STZ ZP_PTR
000671r 1  A9 80          LDA #>SCREEN_buffer
000673r 1  85 23          STA ZP_PTR+1
000675r 1  A2 1E          LDX #30
000677r 1  A9 00          LDA #0
000679r 1                 @loop:
000679r 1  A8               TAY
00067Ar 1  91 22            STA (ZP_PTR),y 	;	set first buffer entry for line mod 4 = 0
00067Cr 1  A0 40            LDY #64 		; 	move buffer pointer to next line
00067Er 1  91 22            STA (ZP_PTR),y 	;	set first buffer entry for line mode 4 =1
000680r 1  A0 80            LDY #128 		; 	move buffer pointer to next line
000682r 1  91 22            STA (ZP_PTR),y 	;	set first buffer entry for line mode 4 =2
000684r 1  A0 C0            LDY #192 		; 	move buffer pointer to next line
000686r 1  91 22            STA (ZP_PTR),y 	;	set first buffer entry for line mode 4 =3
000688r 1  E6 23            INC ZP_PTR+1 	;	next page plz
00068Ar 1  CA               DEX
00068Br 1  D0 EC            BNE @loop
00068Dr 1                 ; fetch bearing data ..
00068Dr 1  AD rr rr       LDA camera_facing
000690r 1  0A             ASL
000691r 1  AA             TAX
000692r 1  7C rr rr       jmp (@T_BEARINGS,X)
000695r 1               @T_BEARINGS:
000695r 1  rr rr        	.addr BEARING_ZERO
000697r 1  rr rr        	.addr BEARING_ONE
000699r 1  rr rr        	.addr BEARING_TWO
00069Br 1               
00069Br 1               BEARING_ZERO:
00069Br 1  A9 70            LDA #112 ; starting at screen Y=112
00069Dr 1                 @E_loop:
00069Dr 1  85 24            STA ZP_PTR+2 ; stash the Y we're working at...
00069Fr 1  64 22              STZ ZP_PTR   ; zero this out to use pointer ..
0006A1r 1  4A                 LSR
0006A2r 1  66 22              ROR ZP_PTR ;
0006A4r 1  4A                 LSR
0006A5r 1  66 22              ROR ZP_PTR ; because is 64 avail for each
0006A7r 1  09 80              ORA #>SCREEN_buffer ; making pointer woot!
0006A9r 1  85 23              STA ZP_PTR+1 ; ZP_PTR points to the line..
0006ABr 1  A0 00              LDY #0 	;	set to first offset in that buffer.. we'll add other objects to the lines later so this will always be null object
0006ADr 1  A9 08              LDA #8 	;   start at X=0
0006AFr 1                   @E_loopE:
0006AFr 1  AA                   TAX
0006B0r 1  A9 02                LDA #2 	;	water type
0006B2r 1  91 22                STA (ZP_PTR),y
0006B4r 1  C8                   iny
0006B5r 1  8A                   TXA ;	get X value
0006B6r 1  91 22                STA (ZP_PTR),y
0006B8r 1  C8                   iny
0006B9r 1  18                   CLC
0006BAr 1  69 10                adc #16
0006BCr 1  C9 88                CMP #136
0006BEr 1  90 EF                BCC @E_loopE 	;kk
0006C0r 1  A9 00              LDA #0
0006C2r 1  91 22              STA (ZP_PTR),y ; stash zero value to end the thing
0006C4r 1  A5 24              LDA ZP_PTR+2
0006C6r 1  E9 0F              SBC #15 	;	borrow is set ...
0006C8r 1  B0 D3              BCS @E_loop ; still spots left on screen.. otay
0006CAr 1  4C rr rr         jmp update_screen
0006CDr 1               BEARING_ONE:
0006CDr 1               BEARING_TWO: ; 30 degrees ..
0006CDr 1  A9 74            LDA #116 ; starting at screen Y=112
0006CFr 1                 @E_loop:
0006CFr 1  85 24            STA ZP_PTR+2 ; stash the Y we're working at...
0006D1r 1  64 22              STZ ZP_PTR   ; zero this out to use pointer ..
0006D3r 1  4A                 LSR
0006D4r 1  66 22              ROR ZP_PTR ;
0006D6r 1  4A                 LSR
0006D7r 1  66 22              ROR ZP_PTR ; because is 64 avail for each
0006D9r 1  09 80              ORA #>SCREEN_buffer ; making pointer woot!
0006DBr 1  85 23              STA ZP_PTR+1 ; ZP_PTR points to the line..
0006DDr 1  A0 00              LDY #0 	;	set to first offset in that buffer.. we'll add other objects to the lines later so this will always be null object
0006DFr 1  A9 0C              LDA #12 	;   start at X=0
0006E1r 1                   @E_loopE:
0006E1r 1  AA                   TAX
0006E2r 1  A9 02                LDA #2 	;	water type
0006E4r 1  91 22                STA (ZP_PTR),y
0006E6r 1  C8                   iny
0006E7r 1  8A                   TXA ;	get X value
0006E8r 1  91 22                STA (ZP_PTR),y
0006EAr 1  C8                   iny
0006EBr 1  18                   CLC
0006ECr 1  69 1C                adc #28
0006EEr 1  C9 88                CMP #136
0006F0r 1  90 EF                BCC @E_loopE 	;kk
0006F2r 1  A9 00              LDA #0
0006F4r 1  91 22              STA (ZP_PTR),y ; stash zero value to end the thing
0006F6r 1  A5 24              LDA ZP_PTR+2
0006F8r 1  E9 0D              SBC #13 	;	borrow is set ...
0006FAr 1  B0 D3              BCS @E_loop ; still spots left on screen.. otay
0006FCr 1  4C rr rr         jmp update_screen
0006FFr 1               
0006FFr 1  60             rts
000700r 1               
000700r 1               update_screen:
000700r 1  9C 20 9F       stz VERA_addr_low
000703r 1  A9 FC          lda #>VRAM_sprite_attributes
000705r 1  8D 21 9F       sta VERA_addr_high
000708r 1  A9 11          lda #$11
00070Ar 1  8D 22 9F       sta VERA_addr_bank
00070Dr 1  A9 77            LDA #119
00070Fr 1  85 24            STA ZP_PTR+2 ; stash line we at ..
000711r 1  64 22              STZ ZP_PTR
000713r 1  4A                 LSR
000714r 1  66 22              ROR ZP_PTR ;
000716r 1  4A                 LSR
000717r 1  66 22              ROR ZP_PTR ; because is 64 avail for each
000719r 1  09 80              ORA #>SCREEN_buffer ; making pointer woot!
00071Br 1  85 23              STA ZP_PTR+1 ; ZP_PTR points to the line..
00071Dr 1                 @y_line_loop:
00071Dr 1  A0 00              LDY #0 ; set to check that first point ..
00071Fr 1  C6 24              dec ZP_PTR+2
000721r 1                   @do_check_line:
000721r 1  B1 22                LDA (ZP_PTR),Y ;	get type
000723r 1  C8                   INY
000724r 1  AA                   TAX
000725r 1  7C rr rr             JMP (@T_objtypes,X) ;
000728r 1                   @T_objtypes:
000728r 1  rr rr                .addr @end_line
00072Ar 1  rr rr                .addr @do_water
00072Cr 1                   @do_water:
00072Cr 1  9C 23 9F           stz VERA_data0 	; 	address 12:5
00072Fr 1  9C 23 9F           STZ VERA_data0 	; 	4bit color address 16:13
000732r 1  B1 22              LDA (ZP_PTR),Y  	;	get the X
000734r 1  C8                 iny
000735r 1  8D 23 9F           STA VERA_data0 	;	X
000738r 1  9C 23 9F           STZ VERA_data0 	;	 X
00073Br 1  A5 24              LDA ZP_PTR+2
00073Dr 1  8D 23 9F           STA VERA_data0 	;	y
000740r 1  9C 23 9F           STZ VERA_data0 	; 	y
000743r 1  A9 0C              LDA #$0C
000745r 1  8D 23 9F           STA VERA_data0 	; 	3 z depth no flip
000748r 1  A9 D0              LDA #$D0 			; 	16x64 no palette offset
00074Ar 1  8D 23 9F           STA VERA_data0
00074Dr 1  80 D2              bra @do_check_line
00074Fr 1                   @end_line:
00074Fr 1  38                   SEC
000750r 1  A5 22                LDA ZP_PTR
000752r 1  E9 40                SBC #64
000754r 1  85 22                STA ZP_PTR
000756r 1  A5 23                LDA ZP_PTR+1
000758r 1  E9 00                SBC #0
00075Ar 1  85 23                STA ZP_PTR+1
00075Cr 1  C9 80                CMP #>SCREEN_buffer
00075Er 1  B0 BD                BCS @y_line_loop
000760r 1  60           rts
000761r 1               
000761r 1               test_cell_sprite_16x8: 	;	16x8x16 bit = 64 bytes
000761r 1               ; 	   01   23   45   67   89   AB   CD   EF
000761r 1  00 00 66 66  .byte $00, $00, $66, $66, $66, $66, $00, $00 	; 	0
000765r 1  66 66 00 00  
000769r 1  00 66 EE EE  .byte $00, $66, $EE, $EE, $EE, $EE, $66, $00  	;	1
00076Dr 1  EE EE 66 00  
000771r 1  06 EE EE EE  .byte $06, $EE, $EE, $EE, $EE, $EE, $EE, $60 	;	2
000775r 1  EE EE EE 60  
000779r 1  6E EE EE EE  .byte $6E, $EE, $EE, $EE, $EE, $EE, $EE, $E6 	;	3
00077Dr 1  EE EE EE E6  
000781r 1  6E EE EE EE  .byte $6E, $EE, $EE, $EE, $EE, $EE, $EE, $E6 	;	4
000785r 1  EE EE EE E6  
000789r 1  06 EE EE EE  .byte $06, $EE, $EE, $EE, $EE, $EE, $EE, $60 	;	5
00078Dr 1  EE EE EE 60  
000791r 1  00 66 EE EE  .byte $00, $66, $EE, $EE, $EE, $EE, $66, $00  	;	6
000795r 1  EE EE 66 00  
000799r 1  00 00 66 66  .byte $00, $00, $66, $66, $66, $66, $00, $00 	; 	7
00079Dr 1  66 66 00 00  
0007A1r 1               
0007A1r 1               test_cell_sprite: 	;	is 16x64x16 bit = 512 bytes
0007A1r 1               ; 	   01   23   45   67   89   AB   CD   EF
0007A1r 1  00 00 66 66  .byte $00, $00, $66, $66, $66, $66, $00, $00 	; 	0
0007A5r 1  66 66 00 00  
0007A9r 1  00 66 EE EE  .byte $00, $66, $EE, $EE, $EE, $EE, $66, $00  	;	1
0007ADr 1  EE EE 66 00  
0007B1r 1  06 EE EE EE  .byte $06, $EE, $EE, $EE, $EE, $EE, $EE, $60 	;	2
0007B5r 1  EE EE EE 60  
0007B9r 1  6E EE EE EE  .byte $6E, $EE, $EE, $EE, $EE, $EE, $EE, $E6 	;	3
0007BDr 1  EE EE EE E6  
0007C1r 1  6E EE EE EE  .byte $6E, $EE, $EE, $EE, $EE, $EE, $EE, $E6 	;	4
0007C5r 1  EE EE EE E6  
0007C9r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $E6, $66 	;	5
0007CDr 1  EE EE E6 66  
0007D1r 1  66 66 EE EE  .byte $66, $66, $EE, $EE, $EE, $EE, $66, $66 	;	6
0007D5r 1  EE EE 66 66  
0007D9r 1  EE 66 66 66  .byte $EE, $66, $66, $66, $66, $66, $66, $EE 	;	7
0007DDr 1  66 66 66 EE  
0007E1r 1               
0007E1r 1  EE EE 66 66  .byte $EE, $EE, $66, $66, $66, $66, $EE, $EE 	; 	8
0007E5r 1  66 66 EE EE  
0007E9r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
0007EDr 1  EE 66 EE EE  
0007F1r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
0007F5r 1  66 EE 66 EE  
0007F9r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
0007FDr 1  EE EE EE 66  
000801r 1               
000801r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	12
000805r 1  EE EE EE EE  
000809r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00080Dr 1  EE 66 EE EE  
000811r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000815r 1  66 EE 66 EE  
000819r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00081Dr 1  EE EE EE 66  
000821r 1               
000821r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	16
000825r 1  EE EE EE EE  
000829r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00082Dr 1  EE 66 EE EE  
000831r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000835r 1  66 EE 66 EE  
000839r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00083Dr 1  EE EE EE 66  
000841r 1               
000841r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	20
000845r 1  EE EE EE EE  
000849r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00084Dr 1  EE 66 EE EE  
000851r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000855r 1  66 EE 66 EE  
000859r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00085Dr 1  EE EE EE 66  
000861r 1               
000861r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	24
000865r 1  EE EE EE EE  
000869r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00086Dr 1  EE 66 EE EE  
000871r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000875r 1  66 EE 66 EE  
000879r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00087Dr 1  EE EE EE 66  
000881r 1               
000881r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	28
000885r 1  EE EE EE EE  
000889r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00088Dr 1  EE 66 EE EE  
000891r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000895r 1  66 EE 66 EE  
000899r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00089Dr 1  EE EE EE 66  
0008A1r 1               
0008A1r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	32
0008A5r 1  EE EE EE EE  
0008A9r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
0008ADr 1  EE 66 EE EE  
0008B1r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
0008B5r 1  66 EE 66 EE  
0008B9r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
0008BDr 1  EE EE EE 66  
0008C1r 1               
0008C1r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	36
0008C5r 1  EE EE EE EE  
0008C9r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
0008CDr 1  EE 66 EE EE  
0008D1r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
0008D5r 1  66 EE 66 EE  
0008D9r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
0008DDr 1  EE EE EE 66  
0008E1r 1               
0008E1r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	40
0008E5r 1  EE EE EE EE  
0008E9r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
0008EDr 1  EE 66 EE EE  
0008F1r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
0008F5r 1  66 EE 66 EE  
0008F9r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
0008FDr 1  EE EE EE 66  
000901r 1               
000901r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	44
000905r 1  EE EE EE EE  
000909r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00090Dr 1  EE 66 EE EE  
000911r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000915r 1  66 EE 66 EE  
000919r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00091Dr 1  EE EE EE 66  
000921r 1               
000921r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	48
000925r 1  EE EE EE EE  
000929r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00092Dr 1  EE 66 EE EE  
000931r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000935r 1  66 EE 66 EE  
000939r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00093Dr 1  EE EE EE 66  
000941r 1               
000941r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	52
000945r 1  EE EE EE EE  
000949r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00094Dr 1  EE 66 EE EE  
000951r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000955r 1  66 EE 66 EE  
000959r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00095Dr 1  EE EE EE 66  
000961r 1               
000961r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	56
000965r 1  EE EE EE EE  
000969r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00096Dr 1  EE 66 EE EE  
000971r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000975r 1  66 EE 66 EE  
000979r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00097Dr 1  EE EE EE 66  
000981r 1               
000981r 1  EE EE EE EE  .byte $EE, $EE, $EE, $EE, $EE, $EE, $EE, $EE 	; 	60
000985r 1  EE EE EE EE  
000989r 1  EE EE 66 EE  .byte $EE, $EE, $66, $EE, $EE, $66, $EE, $EE 	;  	61
00098Dr 1  EE 66 EE EE  
000991r 1  EE 66 EE 66  .byte $EE, $66, $EE, $66, $66, $EE, $66, $EE 	; 	62
000995r 1  66 EE 66 EE  
000999r 1  66 EE EE EE  .byte $66, $EE, $EE, $EE, $EE, $EE, $EE, $66 	; 	63
00099Dr 1  EE EE EE 66  
0009A0r 1               
