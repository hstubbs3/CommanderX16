todo-2023-10-26.txt

2023/10/26
0608 	installed Sublime merge, got CommanderX16 repo started on github as 
		private / MIT license for general exploration/misc things that don't 
		have proper place to live...
TODO 	install assembler / emulator
	DONE

TODO 	explore video modes setup / writing pixels

????	started verastuff.asm

2023/10/27
0745 	working on verastuff.asm
0850 	rainbow.asm OK - have written pixels on screen

	Just a thought... but what if adjusted the h_scale of the screen every line 
	to make perspective?
	Then mode7 style perspective simplifies to orthogonal -> 
		need to write less pixels to screen... 
	would work for maybe like a demo but would have to do inverse scaling of 
	anything that wasn't at the z for that line on the screen. is the xmas demo.

2023/10/28
0800
TODO 	figure out timing interrupts... play with scaling or something..  
TODO 	output some text or something on layer 1 as overlay...80
1300 	ooof... ok.. scale.asm working at least ... minor weirdness with the
		displayed values but the scaling works so.. .
1915 	into the depths... configure for wolf3D clone... 

2145 	OK got something sorta figured out for the HUD/border bit... 	

2023/10/29
???? 	forget when I started.. woke up 9:30AM .. so maybe like 11am? 

1515 	OK got layer0 MAP sorted out and confirmed with pattern written to layer0 tileA
		is amazing how pretty a test pattern can be.
		Next stop - either DDA / raycast using solid colors or fiddling with textures...

2023/10/30
2000 	trying to make sense of VERA FX modes..
		$9F25	CTRL 	| reset | DCSEL - 6bits | ADDRSEL
		DCSEL 2,3,4,5,6 used only - CTRL $4,$6,$8,$A,$C
	changes behavior of $9F29-$9F2C registers
				DCSEL=0 	DCSEL=2
		$9F29 	DC_VIDEO	FX_CTRL 	Trans Write | cacheWrite | cache fill | 1B cache cycle | 16bit hop | 4bit mode | addr1 Mode - 2 bits
			addr1 mode -
				0 	normal VERA
				1 	line draw helper
				2 	poly fill helper
				3 	affine helper

			3 	affine helper 	in 8x8 tiled column mode... 
		$9F2A 	DC_HSCALE 	FX_TILEBASE FX Tile Base Address (16:11) 	6bit tile base=>2K aligned, up to 256 tile definitions affine clip enable
		$9F2B 	DC_VSCALE	FX_MAPBASE 	FX Map Base Address (16:11)		| 	map size - 2bits - 2x2 8x8 32x32 128x128

		DCSEL=4
		$9F29 	FX_X_POS_L 	X position 7:0
		$9F2A 	FX_X_POS_H 	X Pos -9 | ... 5 bits 	| 	X position 10:8
		$9F2B 	FX_Y_POS_L 	Y/X2 Position 7:0
		$9F2C 	FX_Y_POS_H 	Y/X2 pos -9 | ... 5 bits | Y/X2 Position 10:8 

		ok so set ADDR1 indirectly to source pixel using above DCSEL=4 	... ok

		DCSEL=3
		$9F29 	FX_X_INCR_L 	basically 15bit signed fixed with x32 bit... 
		$9F2A	FX_X_INCR_H
		$9F2B 	FX_Y_INCR_L
		$9F2C 	FX_Y_INCR_H

		OK so say 64x64 texture loaded up, FX_POS set to 0,0... to scale it to 48x48 ... s5.9 fixed.. 512*3/4=384
		64/48=4/3 * 512 = 682 	INC - H=$2 L=$AA

		OK... so drawing 4pixel strips, scaled.. each pixel read increments X/Y ... so need to track Y increment..
		set Y INCR to 0.. track this ourselves.. X inc to scale in X direction.
		set autoincrement DATA0 to 8 ... enable cache fill and cache writes ...
		ADRR_SEL=1 

		LDX #$FF
		clc 	
		DO_COLUMN_4PX:
			DO_ROW_4PX:
				lda VERA_DATA1 ; 4 	
				lda VERA_DATA1 ; 4 	8
				lda VERA_DATA1 ; 4 	12
				lda VERA_DATA1 ; 4 	16
				stx VERA_DATA0 ; 4 	20 - cache flushed, ADDR0 goes down 1 line
				lda VERA_ADDR_LOW ; 4 	24
				adc #128 ; 		2 	26
				sta VERA_ADDR_LOW ; 4 30
				lda VERA_ADDR_HIGH ; 4 34
				adc #0 	;	2 	36
				sta VERA_ADDR_HIGH ; 4 	36
				dey ; 2 	38				
				BNE ; 3 	41 	<- 41 cycles per row * 112 rows in column = ~4600 cycles .. 50 cols = ~230,000 .. ~30fps no wiggle..

		always do in pairs, only need to inc ADDR_HIGH on even or odd... EOR #$80 ...
		ldx #$FF
		ldy #numpairs
		;	ZP_PTR = low byte for odd
		;	ZP_PTR+1 = low byte for even
		DO_ROW_PAIR_4PX_INC_EVEN:
			lda VERA_DATA1 ; 4 	
			lda VERA_DATA1 ; 4 	8
			lda VERA_DATA1 ; 4 	12
			lda VERA_DATA1 ; 4 	16
			stx VERA_DATA0 ; 4 	20 - cache flushed, ADDR0 goes down 1 line
			lda ZP_PTR+1 ;	3 	23
			sta VERA_ADDR_LOW ; 4 	27
			inc VERA_ADDR_HIGH ; 6 	33
			;	repeat read/flush 	20 	53
			lda ZP_PTR ; 3 	56
			sta VERA_ADDR_LOW ; 4 	60
			dey ;	2 	62
			BNE ; 3 	65 for 2 rows *56 rows max in column = 3,640 / col .. 182K cycles / screen.. 

		or do as 8px cols ... increment set to 4, do 2 cache writes before shift down
		DO_8PX_COL_ROW: 
			;	read / flush cache -> 20 	20
			;	read / flush cache -> 20 	40
			lda VERA_ADDR_LOW ; 4 	44
			adc #128 ; 2 			46
			sta VERA_ADDR_LOW ; 4 	50
			lda VERA_ADDR_HIGH ; 4 	54
			adc #0 ; 2 				56
			sta VERA_ADDR_HIGH ; 4 	60
			; 	branch = 5 					65 per row * 112 in col = 7,280 * 25 cols = 182K cycles / screen... LOL 

		we have 133,000 cycles per 60 fps.. 266,000 cycles for 30 fps, 400k cycles for 20 fps ... 

		for all the shiggles... what if ... 1px cols, walls stored sideways ... 
		so data0 increment is 8, cache disabled.
		DO_1PX_COL_ROW:
			lda VERA_DATA1 ; 4 	4
			sta VERA_DATA0 ; 4 	8 	8 cycles / pixel.. 

		if just make this a jump table - 112 tall *3 = 336 bytes of code ...

		1 col = 112*8 = 896 + setup .. 200 cols => 179,200 cycles .... if setup ~100 cycles -> 200,000 cycles.. 

		still needed to sort out the Y increment anyway... setup each col would have it baked in.. 
		so just walls ~40fps ? ... 15-20 fps final game shouldn't be problem

		potentially could write walls like 2PX at a time .. but that begs question why not lower resolution?

		why square pixels? if reconfigure to 210x120 .. like 200x110 display.. say 24px high hud.. leaves 86 rows..
		86*8=688/col ... ~100 setup = 800/col - 160k cycles... prob not really worth it but hey its mathed out now

		if anything would go to 320x120 display.. double buffed its 75k .. sure is hefty but other operations simpler?

		keeping current target at ~200x112 draw single column.. now need to find how expensive the raycasting will be...

		although... _technically_ the VERA could do the raycast for us... using the affine mode? 
		Just it could skip corners unless going <1 px at a time.. 

		DO_ASSIST_RAYCAST:
			inx ; 2
			lda DATA1 ; 4 	~12 per cell gone through
			BEQ DO_ASSIST_RAYCAST

		if 100,000 cycles allowed for raycasting.. 200 cols = 500/col / 12 per cell .. ~41 empty cells could be visited..
		except wouldn't want to have to be empty... 
		if enemies assigned to spaces and only so many enemies in the level...
			BRA DO_ASSIST_RAYCAST
		FOUND_ENEMY:
		;	add this enemy to draw list
		DO_ASSIST_RAYCAST:
			inx ; 2
			lda DATA1 ; 4 	~12 per cell gone through
			BEQ DO_ASSIST_RAYCAST
			cmp #ENEMY_COUNT
			BMI FOUND_ENEMY
		HIT_WALL:
			;	

		Yeah you get distance but what slice of what did you hit???!

2023/11/04
0900 	Starting work on the actual raycasting bit.. need to sort out DDA algo..
		reconsidering some of the layout - could have gradient ceiling and floor using static tiles in layer0
		or by using sprites set behind layer0..
		sprites could be like 32x64 and reuse data.. would need like 14 32x64 or 28 16x64 to cover the 3D bit of the screen..
		or swap layer 0 and layer1 as they currently are and add gradient tiles to layer0 tileset?

1045 	OK finally got a grid sorted out for the video display... -.- committed 001
1155 	got a ghetto raycaster in place to test quick little map.. 

2023/11/05
0805 	sorting out map pointers and movement some.. 
1115 	enabled sprites .. getting some basic HUD stuff together.. 
1200 	weird, doesn't appear to be showing map correctly... need to check loading, maybe not put into banked memory.. ? 
1300 	OK HUD map overlay confirmed working ... previously wasn't putting into correct memory locations..


2023/11/10 	Friday - off work cuz veteran's day observed
0745 	downloaded source code for Super Noah's Ark 3D for SNES to port to x16 ... muahahaha
0845 	converted graphics from Super Noah's Ark 3D from lbm to png format for later processing...
0920 	Installed Havoc's Wolf3D editor ... OMG I can actually edit stuff
0935 	Installed ChaosEdit as well for good measure... woot! 
0945 	sound files include .voc for FX and midi for music.... should be simple enough to sort out later.. 
		
		OK.. so now I know I can read in all the original map and graphics files.. 
													disk (uncompressed)	 	RAM 			VRAM
		levels 		64x64 							~200k 		200k 		16k
		walls 		32x32 			1kb 	64 		64k 		264k		64k 	80K		
		sprites 	up to 64x64 	4k 		185 	740K ...
			likely ~50% empty tiles 				320K
			remove shadows to allow mirroring 		~160k  		424k 		160k 	240k
		sound FX 	SNS format 116K total 			116K 		540k 		116k 	356k
		Music 		~34k of midis, <8k each 		34K 		574k 		8k 		374k

		not bad.. PRG ~600K but should fit OK within 512K of RAM.. is wiggle room at least..
		going to 16 color doesn't seem it would look ok.. 
1030 	update TODO's and commit files to GIT


1615 	create base file to do NOAH3Dx16
1930 	OK... dunno why init tiles was being weird ... but yay is working now... 

2023/11/11
??? 	not sure exactly when I started today.. been working on setting up for 'mode7' floor/ceiling
1045 	ok generated palette for use in GIMP for indexed graphics .. 
		ooof... will maybe need more browns in this palette.. 
		in the color ramps there is some duplicated colors - really only 228 colors, so there's room for 27 more colors
		somewhere
		for now generated floor/ceiling using base cx16 palette

1425 	trying out the affine helper thing, for now just trying to draw the floor/ceiling texture repeated across the screen
		isn't working currently.. but need break .. 

1930 	getting back at it
2000 	OK.. 'mode7' thinger sorta working... need to feed it calculated array of startX/Y and X increments... but is working


TODO 	mode7 style for floors / ceiling rendering

TODO 	optimized 256 color palette for game
TODO 	export map1 walls to 64x64 1byte per wall format...
TODO 	port the BSP tracing code to x16 assembler for initial testing 
TODO 	rasterize untextured walls from BSP tracing
TODO 	create Python code to convert walls png's to raw textures
TODO 	load wall textures to banked memory from file
TODO 	rasterize textured walls from BSP tracing
TODO 	get music working
TODO 	get menu working
TODO 	get HUD working
TODO 	get SFX working
TODO 	levels loading/unloading
TODO 	sprites - map1 objects loaded / rendered
TODO 	port AI / logic for everything


TODO 	actual directional movement through level
TODO 	collision detection player vs level
TODO 	DDA algorithm for raycast through world.. 



TODO 	tilemap graphics
TODO 	explore VERA accelerations - line draw
TODO 	explore VERA accelerations - polyfill
TODO 	explore VERA accelerations - affine
	ooo... cache filling... 
	writes 32bits at a time.. 4 pixels wide.. so for like wolf3D style thing do 
	4px strips down.. 	increment after is based on autoincrement..


	; configure affine helper to scale this bit of wall
	; x has height of wall 
	; 						cycles 		bytes
	texture_col_4_wide_loop:		
		lda VERA_data0 	;	4 	4
		lda VERA_data0 	;	4 	8
		lda VERA_data0  ; 	4 	12
		lda VERA_data0 	; 	4 	16
		sta VERA_data0 	;	4 	20
		dec x 			;	2 	22
		BNE texture_col_4_wide_loop ; 3 	25 	for 4 pixels.. 

	lets say wall textures are 64x64 like OG wolf3D - which ran on 286 @4mhz.. 
	64x64 using 8x8 would be 128 bytes map base + 4K if unique tiles..
	wolf3d used 114 tiles total with half being darker versions.. 456K.. oof
	possibly could write tiles to some scratch space in VRAM as needed? 
	writing 8x64 strip - 512 bytes ... fastest method would use routine per strip
	write_texture_strip:
		lda #imm ; 2
		sta #abs ; 4 	6 per byte * 512 = 3072 cycles 
		eyeballing 20fps, have ~400,000 (390x1024) cycles per frame out .. writing 4 pixel strips, worse case some
		screen would need 320/4 = 80 strips written.. 80*3k = 240K cycles ... not bad, worse case some laggy frames?

		enemy sprites - like 32x48 - 1.5K at 256 color .. 48 frames though.. so more texture stripping.
		320x240x256 color would require 75K VRAM ... so no double buffer at all.. 
		should be a HUD - something like 48 pixels or so.. say is 40 so 200px col - 25*200=5,000 cycles max/col..
		80 cols = 400,000 ... exactly the 20 fps budget.. oof.. could shave 5 cycles by unrolling loop.. 320,000 cycles.

		but that's without rendering enemies/sprites- enemies/sprites would also be texture cols.. say average 64 rows
		per col - 64*20=1280*102,400 cycles ... oof..

		would like double-buffer.. maybe fiddle with scaling?.. 320x240
			/1.25 	= 256x192 .. 48K 
			/1.33 	= 240x180 .. 42.2K
			/1.5  	= ~216x160 .. 	33.75K
			/2 		= 160x120 ... 18.75K 

		256x192 - 32px hud => 256x160 to draw.. 160*20=3,200 * 64 cols = 204,800 cycles ... cheeky. 

		96K for the 2 screen buffers leaves 32K for other stuff.. HUD is drawn to buffer so already included or could use
		mapped sprite data or like 1bpp or 2bpp tiled mode.. 64x24 tilemap = 3K .. 1bpp straight data = 1K -> 4K total
		straight sprite data -> 4k for 16 color! ... ok.. say use sprites to fill that in and for menu or whatever.. 
		28K remaining ... enough to stash 7 entire object textures at 256 colors .. but really wouldn't need entire thing.

		and optimize in case tiny - can decide if better to fetch 64x64 or 32x32 or even intermediate size and interpolate.






TODO 	MODE7 demo - Wacky wheels?


TODO 	explore BASIC stuff - can do TSR stuff? 
TODO 	explore sprites stuff